R"rrr(
sandbox = {
	safeList = 
	{
		base = [[
			_VERSION assert error print ipairs next pairs
			pcall select tonumber tostring type unpack xpcall
			collectgarbage
			]],

		tables =
		{
			coroutine = [[
				create resume running status
				wrap   yield
				]],

			math = [[
				abs   acos asin  atan atan2 ceil
				cos   cosh deg   exp  fmod  floor
				frexp huge ldexp log  log10 max
				min   modf pi    pow  rad   random
				sin   sinh sqrt  tan  tanh
				]],

			os = [[
				clock difftime time
				]],

			string = [[
				byte char  find  format gmatch
				gsub len   lower match  reverse
				sub  upper rep   dump
				]],

			table = [[
				insert maxn remove sort
				]]
		}
	},

	safeIO = 
	{
		close = _G.io.close,
		flush = _G.io.flush,
		type = _G.io.type,
		tmpfile = _G.io.tmpfile,
		read = _G.io.read,
		write = _G.io.write,

		input = function(file)
			if file and not _G.io.type(file) then
				file = sandbox.makeSafePath(file)
			end

			return _G.io.input(file)
		end,
		
		output = function(file)
			if file and not _G.io.type(file) then
				file = sandbox.makeSafePath(file)
			end

			return _G.io.output(file)
		end,

		lines = function(fileName)
			if fileName then
				fileName = sandbox.makeSafePath(fileName)
			end

			return _G.io.lines(fileName)
		end,

		open = function(fileName, mode)
			fileName = sandbox.makeSafePath(fileName)
			return _G.io.open(fileName, mode)
		end
	},

	userDir = "",

	isProtectedTable = function(table)
		for tableName in pairs(sandbox.safeList.tables) do
			if sandbox.env[tableName] == table then return true end
		end
		return false
	end,

    makeSafePath = function(path)
        if type(path) ~= "string" then return nil end
        path = path:gsub([[\]], "/")

        if path:match("^[^/]+:") then
            error("absolute path not allowed")
        end

        local segments = {}
        for segment in path:gmatch("[^/]+") do
            if segment == ".." then
                table.remove(segments)
            elseif segment ~= "." then
                table.insert(segments, segment)
            end
        end

        return sandbox.userDir .. table.concat(segments, '/')
    end,

	env = {
		getmetatable = function(obj)
			if(type(obj) == "string") then 
				return nil
			end

			if(type(obj) == "table" and sandbox.isProtectedTable(obj)) then
				return nil
			end

			return _G.getmetatable(obj)
		end,

		setmetatable = function(table, metatable)
			if not sandbox.isProtectedTable(table) then
				_G.setmetatable(table, metatable)
			end
		end,

		load = function(getF, chunkname)
			local firstPiece = getF()
			if type(firstPiece) == "string" and firstPiece:byte(1) == 27 then
				return nil, "bytecode prohibited"
			end

			local useFirst = true

			local getFWrapper = function()
				if useFirst then
					useFirst = false
					return firstPiece
				else
					return getF()
				end
			end

			local f, msg = _G.load(getFWrapper, chunkname)
			if not f then
				return f, msg
			end

			_G.setfenv(f, sandbox.env)
			return f
		end,

		loadstring = function(s, chunkname)
			if s:byte(1) == 27 then
				return nil, "bytecode prohibited" 
			end

			local f, msg = _G.loadstring(s, chunkname)
			if not f then
				return f, msg
			end

			_G.setfenv(f, sandbox.env)
			return f
		end,

		loadfile = function(fileName)
			safeFileName = makeSafePath(fileName)
			local f = _G.io.open(safeFileName, "rb")

			if f then
				local b = f:read(1):byte(1)
				f:close()
				if b == 27 then
					return nil, "bytecode prohibited"
				end

				func, msg = _G.loadfile(safeFileName)

				if not func then
					return func, msg 
				end

				_G.setfenv(func, sandbox.env)
				return func
			else
				return nil, "file does not exist"
			end
		end,

		dofile = function(fileName)
			if fileName then
				sandbox.env.loadfile(fileName)()
			end
		end,

		getfenv = function(f)
			local env = _G.getfenv(f)
			if env == _G then return nil end
			return env
		end,

		setfenv = function(f, table)
			if _G.getfenv(f) == _G or table == _G then return nil end
			return _G.setfenv(f, table)
		end
	},

	init = function(usrDir)
		sandbox.userDir = usrDir

		------ basic lib
		sandbox.safeList.base:gsub("%S+", function(id)
			sandbox.env[id] = _G[id]
		end)

		------ other lib funcs
		for tableName, tableList in pairs(sandbox.safeList.tables) do
			local table = {}
			tableList:gsub("%S+", function(id)
				table[id] = _G[tableName][id]
			end)

			sandbox.env[tableName] = setmetatable({}, {
			    __index = table,
			    __newindex = function(...)
				      error("Sorry, can't modify " .. tableName)
				    end
		  	})
		end

		sandbox.env.io = setmetatable({}, {
			__index = sandbox.safeIO,
			__newindex = function(...)
				error("Sorry, can't modify " .. "io")
			end
		})

		sandbox.env._G = sandbox.env
	end,

	run = function(f, ...)
		local selfArg = nil
    
		if type(f) == "string" then 
			local name = f
			f = sandbox.env
		  
			for segment, separator in name:gmatch("([^.:]+)([.:]*)") do
				f = f[segment]
	      
				if separator == ":" then
					selfArg = f
				elseif separator == "." then
					selfArg = nil
				end
			end
		end

		setfenv(f, sandbox.env)
		
		if selfArg then
			return f(selfArg, ...)
		else
			return f(...)
		end
	end
}

-- easier access from C++
sandboxInit = sandbox.init
sandboxRun = sandbox.run
)rrr"